# PM立志伝：プロジェクト・クロニクル 詳細設計書（改訂版）

**Version**: 2.0  
**Last Updated**: 2025-12-30  
**Document Type**: Detailed Design Specification

---

## 改訂方針

本書は **実装コードを含まず**、以下の形式で設計を記述する：
1. **データ構造**: ERD、クラス図、構造説明（言葉）
2. **処理フロー**: フローチャート、シーケンス図、アルゴリズム説明（擬似コード）
3. **インターフェース**: 関数シグネチャ（型定義のみ）
4. **設計判断**: なぜこの設計か、代替案との比較

---

## 1. プロジェクト構成

### 1.1 モジュール分割方針

**レイヤードアーキテクチャ**を採用し、以下の4層に分離する：

```
┌─────────────────────────────┐
│  Presentation Layer (UI)    │  React Components
├─────────────────────────────┤
│  Application Layer (Logic)  │  Game Engine, Calculators
├─────────────────────────────┤
│  Domain Layer (State)       │  Zustand Store, Business Logic
├─────────────────────────────┤
│  Infrastructure Layer (DB)  │  IndexedDB, Repositories
└─────────────────────────────┘
```

#### 分離の目的
- **テスタビリティ**: UIとロジックを分離し、ロジックを単体テスト可能に
- **再利用性**: ビジネスロジックを複数のUIコンポーネントから利用
- **保守性**: 各層の責務を明確化し、変更の影響範囲を限定

#### 依存関係の原則
- 上位層は下位層に依存するが、逆は禁止
- 各層は自層の抽象に依存し、具象に依存しない（DIP）

---

## 2. データモデル設計

### 2.1 エンティティ関連図（ERD）

```
┌──────────────┐
│  SaveSlot    │
│  (1-5個)     │
└──────┬───────┘
       │ 1
       │ contains
       │ 1
┌──────▼───────┐
│ WorldState   │
└──────┬───────┘
       │ 1
       │ has
       │ n
   ┌───▼────────┬──────────┬──────────┬──────────┐
   │            │          │          │          │
┌──▼────┐  ┌───▼───┐ ┌────▼───┐ ┌───▼────┐ ┌──▼────────┐
│Character│  │Project│ │Rival   │ │Partner │ │Calendar   │
│(社員)   │  │(案件) │ │(競合)  │ │(BP)    │ │(カレンダー)│
└──┬──────┘  └───┬───┘ └────────┘ └────────┘ └───────────┘
   │             │
   │ n           │ 1
   │ assigned    │ contains
   │ to          │ n
   │ 1       ┌───▼───┐
   └─────────┤ Task  │
             │(タスク)│
             └───┬───┘
                 │ generates
                 │ n
             ┌───▼──────┐
             │WeeklyLog │
             │(週次ログ)│
             └──────────┘
```

### 2.2 主要エンティティの詳細

#### 2.2.1 Character（社員）

**目的**: プロジェクトメンバーの能力と状態を管理

**属性設計**:

| 属性名 | 型 | 説明 | 設計判断 |
|--------|-----|------|----------|
| id | UUID | 一意識別子 | ランダムIDでグローバル一意性を保証 |
| name | string | 社員名 | 日本語対応、最大50文字 |
| ageGroup | enum | 年齢層（20s/30-40s/50s+） | 体力特性の決定に使用 |
| statsBlue | object | 表スキル6種 | 各0-10、プロジェクト遂行能力 |
| statsRed | object | 裏スキル6種 | 各0-10、チーム運営能力 |
| stamina | object | 体力状態 | current/max/recoveryRateの3値 |
| traits | array | 特性タグ | 複数特性の組み合わせを許容 |
| isAwakened | boolean | 覚醒済みフラグ | 二つ名開眼の判定 |
| hiddenData | object? | 隠しデータ | 覚醒前はnull、信頼度で解放 |

**設計判断の根拠**:
- **ダブル・ヘキサゴン**: 実務能力と対人能力を分離し、「技術は高いが協調性がない」等のリアルな人物像を表現
- **年齢層enum**: 年齢を直接持たず、特性グループで管理することで、ステレオタイプ的な特徴付けを実現
- **特性タグ配列**: 固定スキル以外の個性を柔軟に追加可能（将来的なMOD対応）

**代替案との比較**:
- ❌ 案1: 単一のスキル配列 → 表/裏の区別がつかず、ゲーム性が薄れる
- ❌ 案2: クラスベース（戦士/魔法使い等） → PMの世界観に合わない
- ✅ 採用案: ダブル・ヘキサゴン → 複雑性と表現力のバランスが最適

---

#### 2.2.2 Project（プロジェクト）

**目的**: 進行中のプロジェクト状態を集約管理

**属性設計**:

| 属性名 | 型 | 説明 | 設計判断 |
|--------|-----|------|----------|
| id | UUID | 一意識別子 | |
| name | string | 案件名 | ユーザー視認用 |
| budget | object | 予算状態 | initial（初期）とcurrent（残高）を分離 |
| schedule | object | スケジュール | start/end/current week を保持 |
| evm | object | EVM指標 | PV/EV/AC/SPI/CPIを含む |
| wbs | array | タスク配列 | Taskエンティティの集合、階層構造は非対応 |
| riskRegistry | array | リスク一覧 | 特定済みリスクの管理 |
| status | enum | 状態 | PLANNING/RUNNING/COMPLETED/FAILED |

**設計判断の根拠**:
- **EVM組み込み**: プロジェクト状態をリアルタイムで可視化するため、EVMをエンティティ内に保持
- **WBS階層構造なし**: 初期バージョンではフラットなタスク配列とし、実装複雑性を低減
- **リスク登録簿**: PMBOKに準拠し、リスク管理の重要性を学習要素として組み込み

**トレードオフ**:
- WBS階層構造を持たせると、親子関係の管理コストが増加
- フラット構造は依存関係の表現が難しいが、`dependencies`配列で対応

---

#### 2.2.3 Task（タスク）

**目的**: WBSの最小単位、作業の進捗と品質を追跡

**属性設計**:

| 属性名 | 型 | 説明 | 設計根拠 |
|--------|-----|------|----------|
| assigneeId | UUID? | 担当者ID | nullableで未アサイン状態を表現 |
| progress | number | 進捗率 0-100 | パーセンテージで直感的 |
| estimatedEffort | number | 見積工数（人日） | EV計算に使用 |
| qualityScore | number | 品質スコア 0-100 | 低いとバグ発生率上昇 |
| riskFactor | number | リスク値 0-100 | 判断スキルで可視化 |
| dependencies | array | 先行タスクID配列 | クリティカルパス算出に使用 |
| isCriticalPath | boolean | クリティカルパス判定 | UIで強調表示 |

**設計判断**:
- **進捗と品質の分離**: 「早く進めたが品質が低い」を表現可能に
- **リスク可視化条件**: `isRiskVisible`フラグで、判断スキル保有者のみリスクを認識できる仕組み

---

### 2.3 データ永続化戦略

#### 2.3.1 IndexedDB 利用方針

**選定理由**:
- ローカルストレージ(5MB制限)では容量不足
- WebSQLは非推奨
- IndexedDBは非同期、大容量（50MB+）対応

**Dexie.js wrapper 採用理由**:
- 生IndexedDB APIは複雑（トランザクション管理が煩雑）
- Dexie.jsはPromiseベース、TypeScript対応
- スキーママイグレーションが容易

#### 2.3.2 ストア構成

**ストア名**: `pm_chronicle_db`

| テーブル名 | 主キー | インデックス | 目的 |
|-----------|--------|-------------|------|
| saves | id (1-5) | updatedAt | セーブスロット管理 |
| logs | id (UUID) | projectId, week, eventType | プレイログ検索 |

**正規化レベル**: 第2正規形（2NF）
- WorldState内にCharacter/Projectを含む非正規構造
- 理由: セーブ/ロードの原子性を保証し、不整合を防止
- トレードオフ: データ重複があるが、読み込み速度優先

---

## 3. 処理フロー設計

### 3.1 ターン処理システム

#### 3.1.1 全体フロー

```
[プレイヤー: 1週間進めるボタン押下]
          ↓
┌─────────────────────────┐
│ 1. 初期化フェーズ         │
│  - 方針設定の確認         │
│  - アサイン状況の検証     │
└───────────┬─────────────┘
            ↓
┌─────────────────────────┐
│ 2. 日次ループ（4回）      │
│  火曜 → 水曜 → 木曜 → 金曜│
└───────────┬─────────────┘
            ↓
   ┌────────▼────────┐
   │ 2.1 進捗計算     │
   │ 2.2 スタミナ消費 │
   │ 2.3 イベント判定 │
   └────────┬────────┘
            ↓
       イベント発生？
       ├─ Yes → 重大？
       │          ├─ Yes → [一時停止、ユーザー介入待ち]
       │          └─ No  → [自動解決]
       └─ No  → 次の日へ
            ↓
┌─────────────────────────┐
│ 3. 週次集計フェーズ       │
│  - EVM更新               │
│  - スタミナ回復          │
│  - ログ記録              │
└───────────┬─────────────┘
            ↓
┌─────────────────────────┐
│ 4. オートセーブ           │
└─────────────────────────┘
            ↓
      [完了、UI更新]
```

#### 3.1.2 進捗計算アルゴリズム（擬似コード）

```
関数 calculateProgress(character, task, policy):
    // ベース進捗 = 担当タスクフェーズに対応するスキル値
    baseProgress = getRelevantSkill(character, task.phase)
    
    // 方針補正
    policyModifier = {
        NORMAL: 1.0,
        QUALITY_FIRST: 0.8,
        RUSH: 1.5
    }[policy]
    
    // 美貌ボーナス（周囲への影響）
    charmBonus = character.statsRed.charm × 0.05
    
    // 覚醒ボーナス
    awakeningBonus = character.isAwakened ? 1.2 : 1.0
    
    // 士気補正
    moralModifier = character.mood / 100
    
    // 最終進捗
    finalProgress = baseProgress 
                  × policyModifier 
                  × (1 + charmBonus) 
                  × awakeningBonus 
                  × moralModifier
    
    return round(finalProgress)
```

**設計判断**:
- **乗算方式**: 各要素を掛け算することで、複数の弱点が重なると大幅に効率低下
- **美貌の影響**: 周囲のメンバーにも効果を及ぼす設計（実装時は全メンバーのcharmの平均を使用）

**代替案**:
- ❌ 加算方式: 効果が線形すぎて、ドラマティックな変化が生まれない
- ✅ 乗算方式: 極端なケース（士気0%で進捗ゼロ）がリアル

---

#### 3.1.3 トラブル発生判定

```
関数 checkTrouble(task, character):
    // 基礎発生率 = (100 - 品質スコア) %
    baseRate = (100 - task.qualityScore) / 100
    
    // 幸運による軽減
    luckMitigation = character.statsRed.luck / 20  // 最大50%軽減
    
    // 最終発生率
    finalRate = baseRate × (1 - luckMitigation)
    
    // 乱数判定
    if random() < finalRate:
        return createTroubleEvent(task)
    else:
        return null
```

**設計判断の根拠**:
- **品質依存**: 品質スコアが低いタスクほどトラブル発生
- **幸運の効果上限**: 最大50%軽減により、完全な無効化は不可

---

### 3.2 EVM（出来高管理）計算

#### 3.2.1 EVM指標の定義

| 指標 | 計算式 | 意味 |
|------|--------|------|
| PV (Planned Value) | Σ(現在週までに完了予定のタスクの見積工数) | 計画値 |
| EV (Earned Value) | Σ(実際の進捗率 × 見積工数) | 出来高 |
| AC (Actual Cost) | 初期予算 - 残予算 | 実コスト |
| SPI | EV / PV | スケジュール効率指数 |
| CPI | EV / AC | コスト効率指数 |

#### 3.2.2 SPI/CPI の解釈

| SPI値 | 状態 | 色 | 意味 |
|-------|------|-----|------|
| ≥ 1.0 | 順調 | 緑 | 予定通りor前倒し |
| 0.9-0.99 | 注意 | 黄 | やや遅延 |
| < 0.9 | 危険 | 赤 | 大幅遅延 |

**設計判断**:
- **リアルタイム計算**: 毎ターン再計算し、プレイヤーに即座にフィードバック
- **閾値設定**: PMBOKの一般的な基準値（0.9）を採用

---

### 3.3 休暇調整パズル

#### 3.3.1 パズル生成ロジック

```
関数 generateVacationPuzzle(period, projectRequirements):
    // 1. 対象期間のカレンダー生成（GW: 4/29-5/5）
    days = generateCalendarDays(period)
    
    // 2. 各メンバーの希望休を特性に基づき生成
    for each character in projectMembers:
        vacationBlock = generateByTrait(character, days)
        memberBlocks.add(vacationBlock)
    
    // 3. 制約条件設定
    constraints = {
        requiredStaffPerDay: projectRequirements,
        budget: getAvailableBudget(),
        apPool: getCurrentAP()
    }
    
    return Puzzle(days, memberBlocks, constraints)
```

#### 3.3.2 特性別の休暇希望生成ルール

| 特性 | 希望休日数 | 交渉可否 | コスト種類 |
|------|-----------|----------|-----------|
| vacation_lover | 最大（7日） | ❌ 不可 | - |
| plan_oriented | 中（5日） | ⚠️ 可（高ストレス） | AP大量消費 |
| money_lover | 少（3日） | ✅ 容易 | 予算消費 |
| standard | 標準（2日） | ✅ 普通 | AP少量消費 |

**設計判断**:
- **決定論的生成**: 同じキャラ+同じ期間なら同じ希望休（ランダム性排除）
- **制約充足問題**: パズルゲームとして成立させるため、必ず解が存在することを保証

---

## 4. 状態管理設計

### 4.1 Zustand ストア構造

```
RootStore
  ├─ worldSlice      (世界状態)
  │   ├─ seed
  │   ├─ calendar
  │   ├─ company
  │   └─ characters[]
  │
  ├─ projectSlice    (プロジェクト状態)
  │   ├─ currentProject
  │   ├─ projects[]
  │   └─ tasks[]
  │
  ├─ characterSlice  (キャラクター操作)
  │   ├─ selectedCharacterId
  │   └─ actions
  │       ├─ updateStamina()
  │       └─ assignToTask()
  │
  └─ uiSlice         (UI状態)
      ├─ activeScreen
      ├─ modalStack
      └─ notifications[]
```

**設計方針**:
- スライスパターン: 関心事ごとに状態を分割
- 単方向データフロー: Action → Reducer → State → UI

**なぜZustand?**:
- Redux: ボイラープレートが多い、学習コスト高
- Context API: パフォーマンス問題（再レンダリング）
- Zustand: シンプル、TypeScript対応、パフォーマンス良好

---

## 5. UIコンポーネント設計

### 5.1 コンポーネント階層

```
App
 ├─ Router
 │   ├─ TitleScreen
 │   ├─ GameSetup
 │   ├─ Dashboard
 │   │   └─ DashboardCard × 6
 │   │
 │   └─ PMCockpit ★メイン画面
 │       ├─ HUD (ヘッダー)
 │       │   ├─ CalendarDisplay
 │       │   ├─ EVMeter × 2
 │       │   └─ BudgetDisplay
 │       │
 │       ├─ OfficeView
 │       │   └─ CharacterCard × n (ドラッグ可能)
 │       │
 │       ├─ GanttChart
 │       │   └─ TaskBar × n (ドロップ可能)
 │       │
 │       └─ ControlPanel
 │           ├─ PolicySelector
 │           └─ ExecuteButton
 │
 └─ ModalManager
     ├─ CharacterDetailModal
     │   └─ HexagonChart × 2
     │
     └─ CardBattleModal
         ├─ BattleField
         ├─ CardHand
         └─ DialogLog
```

### 5.2 Props設計方針

**原則**: Props Drilling を避け、必要な場所でZustandから取得

- ❌ 悪い例: `App → Dashboard → Card → descendant (5層)` にprops伝播
- ✅ 良い例: 各コンポーネントが`useGameStore`で直接取得

**例外**: 再利用性の高い共通コンポーネント（Button, Card等）はpropsで受け取る

---

## 6. インターフェース定義

### 6.1 ゲームエンジン

#### TurnProcessor

```typescript
interface TurnProcessor {
  /**
   * 1週間分のターン処理を実行
   * @param projectId プロジェクトID
   * @param policy 週間方針
   * @returns 週次結果（完了 or 一時停止）
   */
  executeWeekTurn(projectId: string, policy: WeekPolicy): Promise<WeekResult>
}

type WeekPolicy = 'NORMAL' | 'QUALITY_FIRST' | 'RUSH'

type WeekResult = 
  | { status: 'COMPLETED'; summary: WeekSummary; evm: EVMState }
  | { status: 'PAUSED'; pausedAt: number; criticalEvent: GameEvent }
```

**設計判断**:
- async/await: IndexedDB操作が非同期のため
- Union Type: 完了と一時停止を型レベルで区別

---

### 6.2 リポジトリ

#### CharacterRepository

```typescript
interface CharacterRepository {
  /**
   * キャラクター取得
   */
  findById(id: string): Promise<Character | undefined>
  
  /**
   * 全キャラクター取得
   */
  findAll(): Promise<Character[]>
  
  /**
   * キャラクター更新
   */
  update(id: string, updates: Partial<Character>): Promise<void>
  
  /**
   * バッチ更新（トランザクション内）
   */
  updateMultiple(updates: Array<{ id: string; data: Partial<Character> }>): Promise<void>
}
```

**設計判断**:
- Repository Pattern: データアクセスをカプセル化、テスト容易性向上
- Partial型: 一部のフィールドだけ更新可能

---

## 7. 設計パターン適用

### 7.1 Repository Pattern

**目的**: データアクセスロジックをビジネスロジックから分離

**メリット**:
- テスト時、Repositoryをモックに差し替え可能
- IndexedDBからFirebase等への移行が容易

### 7.2 Observer Pattern (Zustand)

**目的**: 状態変更を監視し、UIに自動反映

**メリット**:
- 手動でのUI更新処理が不要
- 状態とUIの同期が保証される

---

## 8. パフォーマンス戦略

### 8.1 IndexedDB アクセス最適化

**戦略**: バッチ処理とトランザクション

```
❌ 悪い例（個別アクセス）:
  for each character:
    await db.characters.get(id)
    await db.characters.put(updated)
  → N回のDB往復

✅ 良い例（トランザクション）:
  await db.transaction('rw', db.characters, async () => {
    // 1トランザクション内で全処理
  })
  → 1回のDB往復
```

### 8.2 React レンダリング最適化

**戦略**:
- `useMemo`: 重い計算結果のキャッシュ（ガントチャートレイアウト計算）
- `useCallback`: イベントハンドラの安定化
- `React.memo`: 変更されていないコンポーネントのスキップ

---

## 9. エラーハンドリング戦略

### 9.1 エラー分類

| エラー種別 | 対処方法 | 例 |
|-----------|---------|-----|
| バリデーションエラー | ユーザーに通知、操作を阻止 | 「スタミナ不足でアサインできません」 |
| データ不整合 | 強制リロード、セーブ復元 | IndexedDBが破損 |
| ネットワークエラー（AI） | リトライ、ローカル代替処理 | AI API タイムアウト |
| 予期しないエラー | エラーバウンダリでキャッチ、状態リセット | JavaScript例外 |

---

## 10. 設計判断の記録

### 10.1 なぜLocal-Firstか？

**判断**: すべてをクライアント側で完結

**理由**:
1. オフライン動作 → ネットワーク不要
2. プライバシー → データをサーバーに送らない
3. レスポンス速度 → サーバー通信遅延なし
4. インフラコスト削減 → サーバーレス

**代償**:
- マルチプレイ不可（将来、P2P等で対応）
- データ同期が難しい（エクスポート/インポートで代用）

### 10.2 なぜReact+Viteか？

**判断**: Next.jsではなくVite

**理由**:
- SSR不要（SPAで十分）
- Viteのビルド速度が圧倒的に速い
- シンプルな構成で学習コスト低

**代償**:
- SEO不要なゲームなので問題なし

---

**次ページ: テスト設計書へ続く**
